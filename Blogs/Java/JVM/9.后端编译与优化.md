
### 概述

在前端编译器中，“优化”手段主要用于提升程序的编码效率，之所以把javac这类将Java代码变为字节码的编译器称作前端编译器，是因为它只完成了从程序到抽象语法树或中间字节码的生成，而在此之后，还有一组**内置于Java虚拟机内部的后端编译器来完成代码优化以及从字节码生成本地机器码的过程**，即之前多次提到的即时编译器或提前编译器，这个后端编译器的编译速度及编译结果质量高低，是衡量Java虚拟机性能最重要的一个指标。

> 本节中提及的即时编译器都是特指HotSpot虚拟机内置的即时编译器，虚拟机也是特指HotSpot虚拟机

### 即时编译器

目前主流的两款商用Java虚拟机（HotSpot、OpenJ9）里，Java程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为“热点代码”，为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器被称为即时编译器。

#### 解释器与编译器

主流的商用Java虚拟机内部都同时包含解释器与编译器，解释器与编译器两者各有优势：**当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率。当程序运行环境中内存资源限制较大，可以使用解释器执行节约内存，反之可以使用编译执行来提升效率。**

HotSpot虚拟机内置了两个(或三个)即时编译器，其中有两个编译器存在已久，分别称为客户端编译器和服务端编译器，或者简称为C1编译器和C2编译器。第三个是在JDK10才出现的、长期目标是替代C2的Graal编译器，Graal编译器目前还处于实验状态。

无论采用的编译器是客户端编译器还是服务端编译器，解释器与编译器搭配使用的方式在虚拟机中被称为混合模式。用户也可以控制让虚拟机运行于解释模式，这样编译器不介入工作，全部代码由解释方式执行。也可以强制虚拟机运行于编译模式，这时将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。

为了在程序启动速度与运行效率之间达到最佳平衡，HotSpot虚拟机在编译子系统中加入了分层编译的功能。分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次。

#### 编译对象与触发条件

在运行过程中会被即时编译器编译的目标是热点代码，主要有两类：

- 被多次调用的方法
- 被多次执行的循环体

对于这两种情况，编译的目标对象都是整个方法体，而不会是单独的循环体。

要知道某段代码是不是热点代码，是不是需要触发即时编译，这个行为称为热点探测，其实进行热点探测并不一定要知道方法具体被调用了多少次，目前主流的热点探测判定方式有两种：

1. 基于采样的热点探测：周期性地检查各个线程的调用栈顶，如果发现某个方法经常出现在栈顶，那这个方法就是热点方法。
2. 基于计数器的热点探测：采用这种方法的虚拟机会为每个方法建立计数器，统计方法的执行此时，如果执行次数超过一定的阈值就认为它是热点方法。

在HotSpot虚拟机中使用的是第二种基于计数器的热点探测方法，为了实现热点计数，HotSpot为每个方法准备了两类计数器：方法调用计数器和回边计数器（回边的意思是指在循环边界往回跳转）。

当一个方法被调用时，虚拟机会先检查该方法是否存在被即时编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将该方法的调用计数器值加1，然后判断方法调用计数器与回边计数器之和是否超过方法调用计数器的阈值。

执行引擎默认不会同步等待编译请求完成，而是继续进行解释器按照解释方式执行字节码，直到提交的请求被即时编译器编译完成。当编译工作完成后，这个方法的调用入口地址就会被系统自动改写成新值，下一次调用该方法时就会使用已编译的版本了，整个即时编译的交互过程如下图所示：

![](https://raw.githubusercontent.com/xfhy/Android-Notes/master/Images/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A6%E5%8F%91%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91.png)

方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，该方法的调用计数器就会被减少一半，这个过程被称为方法调用计数器热度的衰减，而这段时间被称为此方法的半衰周期。进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的。

回边计数器，它的作用是统计一个方法中循环体代码执行的次数。当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，它将会优先执行已编译的代码，否则就将回边计数器的值加1，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。

#### 编译过程

默认情况下，无论是方法调用产生的标准编译请求，还是栈上替换编译请求，虚拟机在编译器还未完成编译之前，都仍然将按照解释方式继续执行代码，而编译动作则在后台的编译线程中进行。

在后台执行编译的过程中，对于客户端编译器来说，它是一个相对简单快速的三段式编译器，主要的关注点在于局部的优化，而放弃了许多耗时较长的全局优化手段

1. 第一阶段，一个平台独立的前端将字节码构造成一种高级中间代码（HIR）表示
2. 第二阶段，一个平台相关的后台从HIR中产生低级中间代码(LIR)表示。
3. 第三阶段，在平台相关的后端使用线性扫描算法在LIR上分配寄存器，并在LIR上做窥孔优化，然后产生机器代码。

![](https://raw.githubusercontent.com/xfhy/Android-Notes/master/Images/Client_Compiler%E6%9E%B6%E6%9E%84.png)

而服务端编译器则是专门面向服务端的典型应用场景，并为服务端的性能配置针对性调整过的编译器，也是一个能容忍很高优化复杂度的高级编译器。它会执行大部分经典的优化动作，如无用代码消除、循环展开、常量传播、消除公共子表达式等。

### 提前编译器

2013年，在Android中使用提前编译的ART横空出世。

#### 提前编译的优劣得失

现在提前编译产生和对其的研究有着两条明显的分支，一条分支是做与传统C、C++编译器类似的，在程序运行之前把程序代码编译成机器码的静态翻译工作；另外一条分支是把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码（譬如公共库代码在被同一台机器其他Java进行使用）时直接把它加载进来使用。

先说第一条，这是传统的提前编译应用形式，它在Java中存在的加载直指**即时编译的最大弱点：即时编译要占用程序运行时间与运算资源**。

如果是在程序运行之前进行的静态编译，耗时的优化就可以放心大胆地进行了。这也是ART打败Dalvik的主要武器之一，连副作用也是相似的。在Android 5.0和6.0版本，安装一个稍微大一点的Android应用就得很长时间，以至于从Android 7.0版本起重新启用了解释执行和即时编译（但这与Dalvik无关，它彻底凉了），等空闲时系统再在后台自动进行提前编译。

关于提前编译的第二条路径，本质是给即时编译器做缓存加速，去改善Java程序的启动时间，以及需要一段时间预热后才能达到最高性能的问题。

尽管即时编译在时间和运算资源方面的劣势是无法忽视的，但其依然有自己的优势：

1. 性能分析制导优化：如果一个条件分支的某一条路径执行特别频繁，而其他路径鲜有问津，那就可以把热的代码集中放到一起，集中优化和分配更好的资源（分支预测、寄存器、缓存等）给它。
2. 激进预测性优化：如果性能监控信息能够支持它做出一些正确的可能性很大但无法保证绝对正确的预测判断，就已经可以大胆地按照高概率的假设进行优化，万一真的走到罕见分支上，大不了退回到低级编译器甚至解释器上去执行，不会出现无法挽救的后果。
3. 链接时优化：Java语言天生就是动态链接的，一个个class文件在运行期被加载到虚拟机内存当中，然后在即时编译器里产生优化后的本地代码。

### 编译器优化技术

编译器的目标虽然是做由程序代码翻译为本地机器码的工作，但其实难点并不在于能不能成功翻译出机器码，输出代码优化质量的高低才是决定编译器优秀与否的关键。

#### 优化技术概览

即时编译器对这些代码优化变化是建立在代码的中间表示或者是机器码之上的，绝不是直接在Java源码上去做的，这里只是笔者为了方便讲解，使用了Java语言的语法来表示这些优化技术所发挥的作用。

先来个简单示例，这是优化前的原始代码：

```java
static class B {
    int value;
    final int get() { 
        return value;
    } 
}
public void foo() { 
    y = b.get();
    // ...do stuff... 
    z = b.get();
    sum = y + z;
}
```

首先，第一个要进行的优化是**方法内联，它的主要目的有两个：一是去除方法调用的成本（如查找方法版本、建立栈帧等）；二是为其他优化建立良好的基础。**