
### 线程安全

线程安全：当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。

#### 线程安全的实现方法

##### 互斥同步

互斥同步是一种最常见也是最主要的并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一条（或者是一些，当使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是常见的互斥实现方式。

最基本的互斥同步手段就是synchronized关键字，这是一种块结构的同步语法。synchronized关键字经过javac编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作为reference；如果没有明确指定，那将根据synchronized修饰的方法类型（如实例方法或类方法），来决定是取代码所在的对象实例还是取类型对应的class对象来作为线程要持有的锁。

在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一，而在执行monitorexit指令时会将锁计数器的值减一。一旦计数器的值为零，锁随即就被释放了。如果获取对象锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。

- 被synchronized修饰的同步块对同一条线程来说是可重入的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况
- 被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出。

从执行成本的角度看，持有锁是一个重量级的操作。

自JDK5起，Java类库中新提供了java.util.concurrent包，其中java.util.concurrent.Lock接口便成了Java的另一种全新的互斥同步手段。基于Lock接口，用户能够以非块结构来实现互斥同步。

重入锁（ReentrantLock）是Lock接口最常见的一种实现，它与synchronized一样是可重入的。ReentrantLock与synchronized相比增加了一些高级功能，主要有：等待可中断、可实现公平锁、可以绑定多个条件。

- 等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助
- 公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来一次获得锁：而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致ReentrantLock性能急剧下降，会明显影响吞吐量。
- 锁绑定多个条件：是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多余一个的条件关联的时候，就不得不额外添加一个锁；而ReentrantLock则无须这样做，多次调用newCondition()方法即可。

JDK6中加入了大量针对synchronized锁的优化措施，所以性能不再是选择synchronized或者ReentrantLock的决定因素。

ReentrantLock在功能上是synchronized的超集，在性能上又至少不会弱于synchronized，那么为什么不直接抛弃synchronized？ 下面这些场景下，synchronized比ReentrantLock更适合

- synchronized是在Java语法层面的同步，简单&清晰。每个Java程序员都熟悉synchronized，但JUC中的Lock接口则并非如此。因此在只需要基础的同步功能时，更推荐synchronized
- Lock应该确保在finally中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话，则可以由Java虚拟机来确保即时出现异常，锁也能被自动释放
- 尽管在JDK5时代ReentrantLock曾经在性能上领先过synchronized，但这已经是十多年前的胜利了。从长远来看，Java虚拟机更容易针对synchronized来进行优化，因为Java虚拟机可以在线程和对象的元数据中记录synchronized中锁的相关信息，而使用JUC中的Lock的话，Java虚拟机是很难得知具体哪些锁对象是由特定线程锁持有的。

##### 非阻塞同步

### 锁优化
