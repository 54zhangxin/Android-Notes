### 概述

编译期没有具体的上下文语境的话，其实是一个模糊的表述。它可能是下面3种情况：

- 前端编译器（叫“编译器的前端“更准确）把.java文件转换成.class文件的过程
- Java虚拟机的即时编译器（**JIT编译器**，Just In Time Compiler）运行期把字节码转变成本地机器码的过程
- 使用静态的提前编译器（**AOT编译器**，Ahead Of Time Compiler）直接把程序编译成与目标机器指令集相关的二进制代码的过程

Java虚拟机设计团队选择把对性能的优化全部集中到运行期的即时编译器中，这样可以让那些不是由javac产生的class文件（如JRuby、Groovy等语言的class文件）也同样能享受到编译器优化措施所带来的性能红利。

相当多新生的Java语法特性，都是靠编译器的语法糖来实现的，而不是依赖字节码或者Java虚拟机的底层改进来支持。

### javac编译器

#### javac的编译过程

大致可以分成4个步骤：

1. 准备过程：初始化插入式注解处理器
2. 解析与填充符号表过程
    - 词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树
    - 填充符号表。产生符号地址和符号信息
3. 插入式注解处理器的注解处理过程
4. 分析与字节码生成过程
    - 标注检查：对语法的静态信息进行检查
    - 数据流及控制流分析：对程序动态运行过程进行检查

#### 解析与填充符号表

**词法、语法分析**

词法分析是将源代码的字符流转变为标记集合的过程，单个字符是程序编写时的最小元素，但标记才是编译时的最小元素。关键字、变量名、字面量、运算符都可以作为标记。

词法分析是根据标记序列构造抽象语法树的过程，抽象语法树是一种用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值甚至连代码注释都可以是一种特定的语法结构。

**填充符号表**

完成了语法分析和词法分析之后，下一阶段是对符号表进行填充的过程。符号表是由一组符号地址和符号信息构成的数据结构。

#### 注解处理器

JDK6设计了一组被称为插入式注解处理器的标准API，可以提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程。我们可以把插入式注解处理器看作是一组编译器的插件，当这些插件工作时，允许读取、修改、添加抽象语法树中的任意元素。

有了编译器注解处理的标准API后，程序员的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件中被访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间（例如：编译时获取注解信息，并据此产生Java代码文件，无性能损失，如ButterKnife、Dagger2等）。

#### 语义分析与字节码生成

经过语法分析之后，编译器获得了程序代码的抽象语法树表示，抽象语法树能够表示一个结构正确的源程序，但无法保证源程序的语义是符合逻辑的。而语义分析的主要任务则是对结构上正确的源程序进行上下文相关性质的检查，譬如进行类型检查、控制流检查、数据流检查等等。

我们在编码时经常能在IDE中看到红线标注的错误提示，其中绝大部分都是来源于语义分析阶段的检查结果。

##### 标注检查

javac在编译过程中，语义分析过程可分为标注检查和数据及控制流分析两个步骤。

标注检查步骤要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等等。在标注检查中，还会顺便进行一个称为常量折叠的代码优化，这是javac编译器会对源代码做的极少量优化措施之一（代码优化几乎都在即时编译器中进行）。

```java
int a = 1 + 2;
```

上面这段代码在抽象语法树上仍然能看到字面量`1`、`2`和操作符`+`号，但是经过常量折叠优化之后，它们将会被折叠为字面量`3`。由于编译期间进行了常量折叠，所以在代码里定义`a=1+2`比起直接定义`a=3`并不会增加程序运行期哪怕仅仅一个处理器时钟周期的处理工作量。

##### 数据及控制流分析

数据流分析和控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受检异常都被正确处理了等问题。

##### 解语法糖

语法糖指的是在计算机语言中添加的某种语法，这种语法对语言的编译结果和功能并没有实际影响，但是却能更方便程序员使用该语言。

Java中最常见的语法糖包括：泛型、变长参数、自动装箱拆箱等等。Java虚拟机运行时并不直接支持这些语法，它们在编译阶段被还原回原始的基础语法结构，这个过程被称为解语法糖。

##### 字节码生成

字节码生成是javac编译过程的最后一个阶段。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转换成字节码指令写到磁盘中，编译器还进行了少量的代码添加和转换工作。

例如实例构造器`<init>()`方法和类构造器`<clinit>()`方法就是在这个阶段被添加到语法树之中的。

除了生成构造器以外，还有其他的一些代码替换工作用于优化程序某些逻辑的实现方式，如把字符串的加操作替换为StringBuffer或StringBuilder（取决于目标代码的版本是否大于或等于JDK5）的append()操作等等。

### Java语法糖

语法糖可以方便程序员的代码开发，虽然它们不会提供实质性的功能改进，但是它们能提高效率。语法糖总体可以看做是前端编译器的一些小把戏，最后还是得还原才能在虚拟机上运行。

#### 泛型

泛型的本质是参数化类型或参数化多态的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数类型能够用在类、接口和方法的创建中，分别构成了泛型类、泛型接口和泛型方法。泛型让程序员能够针对泛化的数据类型编写相同的算法，这极大地增强了编程语言的类型系统及抽象能力。

##### Java与C#的泛型

##### 类型擦除

#### 其他语法糖

### 需要用的资料

```java
public class Temp {

    public static void main(String[] args) {
        Integer a = 1;
        Integer b = 2;

        //Integer默认是缓存-128到127的实例，有缓存则直接用已有的
        Integer c = 3;
        Integer d = 3;
        
        Integer e = 321;
        Integer f = 321;
        
        Long g = 3L;
        
        System.out.println(c == d); //true  有缓存
        System.out.println(e == f); //false  无缓存
        System.out.println(c == (a + b)); //true 有算术运算，自动拆箱了
        System.out.println(c.equals(a + b)); //true integer3.equals(Integer.valueOf(integer1.intValue() + integer2.intValue()))
        System.out.println(g == (a + b));//true 有算术运算，自动拆箱了
        System.out.println(g.equals(a + b)); //false  类型不一样
    }
}

public class Temp {
  public static void main(String[] paramArrayOfString) {
    Integer integer1 = Integer.valueOf(1);
    Integer integer2 = Integer.valueOf(2);
    Integer integer3 = Integer.valueOf(3);
    Integer integer4 = Integer.valueOf(3);
    Integer integer5 = Integer.valueOf(321);
    Integer integer6 = Integer.valueOf(321);
    Long long_ = Long.valueOf(3L);
    System.out.println((integer3 == integer4));
    System.out.println((integer5 == integer6));
    System.out.println((integer3.intValue() == integer1.intValue() + integer2.intValue()));
    System.out.println(integer3.equals(Integer.valueOf(integer1.intValue() + integer2.intValue())));
    System.out.println((long_.longValue() == (integer1.intValue() + integer2.intValue())));
    System.out.println(long_.equals(Integer.valueOf(integer1.intValue() + integer2.intValue())));
  }
}



```