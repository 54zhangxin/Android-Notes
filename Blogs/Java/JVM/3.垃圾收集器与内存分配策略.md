
> Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。-《深入理解Java虚拟机》

### 什么是垃圾

程序计数器、虚拟机栈、本地方法栈这3个区域生命周期是和线程同步的，所以不用过多考虑回收问题。

而Java堆和方法区则有着明显的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所指向的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理。

垃圾就是内存中已经没用的对象。Java虚拟机使用**可达性分析算法**来决定哪些对象是垃圾，是否可以被回收。

### 对象是否已经死了？

垃圾收集器在堆进行回收前，需要判断对象是否不被使用了。有以下2种方式：

**1.引用计数法**

给对象添加一个引用计数器，每当有一个地方引用时，计数器值加一。当引用失效时，计数器值减一；任何时刻计数器为零的对象就是不可能再被使用的。  引用计数法实现简单，判断效率高，但是Java虚拟机里面没有选用引用计数法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。

**2.可达性分析算法**

可达性分析算法的基本思路是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当有一个对象到GC Roots没有任何引用链相连，即不可达，则证明此对象是不可用的。

可作为GC Roots的对象包括下面几种：

- **虚拟机栈（栈帧中的本地变量表）中引用的对象**，比如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
- **方法区中类静态属性引用的对象**，比如Java类的引用类型静态变量
- **方法区中常量引用的对象**，比如字符串常量池（String Table）里的引用
- **本地方法栈JNI（Native方法）引用的对象**
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NPE,OOM）等，还有系统类加载器
- 所有被同步锁（synchronized关键字）持有的对象
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

### 再谈引用

#### 强引用

如果一个对象具有强引用，那垃圾收集器不会回收它。指在程序代码之中普遍存在的引用赋值，即类似“Objectobj=new Object()”这种引用关系。

#### 软引用

在内存实在不足时，会对软引用进行回收。在JDK 1.2版之后提供了SoftReference类来实现软引用

#### 弱引用

弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一个垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。

#### 虚引用

一个对象是否有虚引用的存在，完全不会对齐生存时间构成影响，也无法通过虚引用来获取一个对象的实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。

### 垃圾收集算法

#### 标记-清除算法

> 标记之后原地清除。

首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

不足：

- 效率问题：标记和清除两个过程的效率都不高
- 空间问题：标记清除后会产生大量不连续的内存碎片，空间碎片太多可能导致无法分配较大对象而不得不提前触发另一次垃圾收集动作

#### 标记-复制算法

> 平时只用一半空间，需要回收时，将存活的全部复制到另一半空间，将之前的一半空间全部清除。

标记-复制算法也称为复制算法。

为了解决效率问题，复制算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当这块内存用完了，就将还存活的对象复制到另外一块，然后将已使用那块内存空间一次清理掉。实现简单，运行高效。但是这种算法的代价是可使用内存缩小为原来的一半。

现在虚拟机都采用复制算法来回收新生代。按照历史经验，新生代的对象98%的对象都是朝生夕死，所以并不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的Eden区和两块较小的Survivor空间，每次使用Eden区和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。当然，如果Survivor空间装不下时，需要依赖其他内存（一般是老年代）进行分配担保。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是只有10%的内存会浪费。

复制算法在对象存活率比较高的时候是非常低效的，更关键的是，如果不想浪费50%的内存空间，就要有额外的空间进行分配担保，所以老年代一般不会选用复制算法。

#### 标记-整理算法

> 标记之后，将对象全部复制到空间的一边，将复制之后占用内存的边界之外的空间全部清理。

和标记清除算法的标记过程一直，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

### 什么时候回收垃圾

不同的虚拟机实现有着不同的GC实现机制，但是一般情况下每一种GC实现都会在以下两种情况下触发垃圾回收。

- Allocation Failure ： 在堆内存中分配时，如果因为可用剩余空间不足导致对象内存分配失败，这时系统会触发一次GC
- System.gc()： 在应用层，可以主动调用此API来建议虚拟机执行一次GC。

### 内存分配与回收策略

对于内存分配，大方向上就是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲区，将按线程优先在TLAB上分配。少数情况下也可以直接分配在老年代。

Java虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为**新生代、老年代**，这就是JVM的内存分代策略。**在HotSpot中除了新生代和老年代，还有永久代**。

分代回收的中心思想：对于新创建的对象会在新生代中分配内存，此区域的对象生命周期一般较短。如果经过多次回收仍然存活下下来，则将它们转移到老年代中。

#### 年轻代（Young Generation）

新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低，在新生代中，常规应用进行一次垃圾收集一般可以回收70%-95%的空间，回收效率很高。新生代中因为要进行一些复制操作，所以一般采用的GC回收算法就是复制算法。

新生代又可以继续细分为3部分：Eden、Survivor0、Survivor1。这3部分按照8：1：1的比例来划分新生代。

![](https://raw.githubusercontent.com/xfhy/Android-Notes/master/Images/JVM%E5%88%86%E4%BB%A3%E6%A6%82%E6%8B%AC.png)

大多数情况下，对象在新生代Eden区分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。

- 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也比较快
- 老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现Major GC，经常会伴随至少一次Minor GC，Major GC的速度一般会比Minor GC慢10倍以上

#### 老年代（Old Generation）

一个对象如果在新生代存活了足够长的时间而没有被清理掉，则会被复制到老年代。老年代的内存大小一般比新生代大，能存放更多的对象。

如果对象比较大（比如字符串或者大数组），并且新生代的剩余空间不足，则这个大对象直接被分配到老年代上。我们可以使用 -XX:PretenureSizeThreshold 来控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上。老年代因为对象的生命周期较长，不需要过多的复制操作，所以一般采用标记整理的回收算法。

长期存活的对象将进入老年代：既然虚拟机采用了分代收集的思想来管理内存，那么内存回收就必须能识别哪些对象应该放在新生代还是老年代。为了做到这一点，虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区每熬过一次Minor GC，年龄就会增加一岁。当它的年龄增加到一定程度，默认是15，就将会被晋升到老年代中。

> 对于老年代可能存在一种情况，老年代中的对象有时候会引用到新生代对象。这时如果要执行新生代GC，则可能需要查询整个老年代上可能存在引用新生代的情况，这显然是低效的。所以，老年代维护了一个512byte的card table，所有老年代对象引用新生代对象的信息都记录在这里。每当新生代发送GC时，只需要检查这个card table即可，大大提高了性能。



## 资料

- [ ] HotSpot算法实现 
- [ ] 各种垃圾收集器


- 《深入理解Java虚拟机》
- [Android 工程师进阶 34 讲](https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67#/content)