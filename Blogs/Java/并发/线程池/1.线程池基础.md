- [1. 前言](#head1)
- [2. 线程池比手动创建线程好在哪里](#head2)
- [3. 线程池的参数](#head3)
- [4. ThreadPoolExecutor执行任务大致流程](#head4)
- [5. 线程池分类](#head5)
	- [5.1 FixedThreadPool](#head6)
	- [5.2 CachedThreadPool](#head7)
	- [5.3 ScheduledThreadPool](#head8)
	- [5.4 SingleThreadExecutor](#head9)

线程池基础
---

### <span id="head1">1. 前言</span>

线程池的出现是为了解决什么问题?

1. 反复创建线程系统开销比较大,每个线程创建和销毁都需要时间,如果任务比较简单,那么就有可能导致创建和销毁线程消耗的资源比线程执行任务本身消耗的资源还要大
2. 过多的线程会占用过多的内存等资源,还会带来过多的上下文切换,同时会导致系统不稳定

针对反复创建线程开销大的问题,线程池用一些固定的线程一直保持工作状态反复执行任务.

其次,针对过多线程占用内存资源的问题,线程池会根据需要创建线程,控制线程的总数量,避免占用过多内存资源.

### <span id="head2">2. 线程池比手动创建线程好在哪里</span>

1. 线程池可以解决线程生命周期的系统开销问题,同时还可以加快相应速度.
2. 线程池可以统筹内存和CPU的使用,避免资源使用不当.
3. 线程池可以统一管理资源.

### <span id="head3">3. 线程池的参数</span>

线程池(Executor)的实现是ThreadPoolExecutor.下面是ThreadPoolExecutor的构造方法中的参数含义

```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {}
```

- corePoolSize : 核心线程数.默认情况下,核心线程会在线程池中一直存活,即使它们处于闲置状态.如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true,则闲置的核心线程在等待新任务到来时会有超时策略,这个时间间隔由keepAliveTime所指定,当等待时间超过keepAliveTime所指定的时长后,核心线程也会被终止.
- maximumPoolSize : 线程池所能容纳的最大线程数,当活动线程数达到这个数值后,后续的新任务将会阻塞.
- keepAliveTime : 非核心线程闲置时的超时时长,超过该时长,非核心线程就会被回收.当ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true时,keepAliveTime同样会作用于核心线程.
- unit : 用来指定keepAliveTime参数的时间单位.
- workQueue : 线程池中的任务队列,通过线程池的execute方法提交的Runnable对象会存在在这个队列中
- threadFactory : 线程工厂,为线程池提供创建新线程的功能.ThreadFactory是一个接口,它只有一个方法: `Thread newThread(Runnable r)`
- handler : 处理被拒绝的任务.当线程池无法执行新任务时,这可能是由于任务队列已满或者是无法成功执行任务,这个时候ThreadPoolExecutor会调用handler的rejectedExecution方法来通知调用者.默认情况下,rejectedExecution方法会直接抛出一个RejectedExecution.

### <span id="head4">4. ThreadPoolExecutor执行任务大致流程</span>

1. 如果线程池中的线程数量未达到核心线程的数量,那么会直接启动一个核心线程来执行任务
2. 如果线程池中的线程数量已经达到或者一键超过核心线程的数量,那么任务会被插入到任务队列中排队等待执行
3. 如果在步骤2中无法将任务插入到任务队列中,这往往是由于任务队列已满,这个时候如果线程数量未达到线程池规定的最大值,那么会立刻启动一个非核心线程来执行任务
4. 如果步骤3中线程数量已经达到线程池规定的最大值,那么就拒绝执行此任务.ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者.

### <span id="head5">5. 线程池分类</span>

> 下面是Android中最常见的四类具有不同功能特性的线程池,其实最终都是通过ThreadPoolExecutor来实现自己的功能特性.

#### <span id="head6">5.1 FixedThreadPool</span>

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    //只有核心线程 没有超时机制
    return new ThreadPoolExecutor(nThreads, nThreads,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>());
}
```

Executors的newFixedThreadPool方法创建.它是一种线程数量固定的线程池,当线程处于空闲状态时,它们并不会被回收,除非线程池被关闭了.当所有的线程都处于活动状态时,新任务都会处于等待状态,直到有线程空闲出来.由于FixedThreadPool只有核心线程并且这些核心线程不会被回收,这意味着它能更加快速地响应外界的请求.

#### <span id="head7">5.2 CachedThreadPool</span>

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                    60L, TimeUnit.SECONDS,
                                    new SynchronousQueue<Runnable>());
}
```

通过Executors的newCachedThreadPool方法创建.它是线程数量不定的线程池,只有非核心线程,并且最大线程数是Integer.MAX_VALUE.当线程池中的线程都处于活动状态时,线程池会创建新的线程来处理新任务,否则会利用空闲线程来处理新任务.线程池中的空闲线程有超时机制,为60秒,超过时间闲置线程就会被回收.和FixedThreadPool不同的是,CachedThreadPool的任务队列其实相当于一个空集合,这将导致任何任务都会立刻被执行,因为在这种场景下SynchronousQueue(SynchronousQueue是一个非常特殊的队列,在很多情况下可以把它简单理解为一个无法存储元素的队列)是无法插入任务的. 从特性看,这类线程池比较适合执行大量耗时较少的任务,当整个线程池都处于闲置状态时,线程池中的线程都会超时而被停止,这个时候CachedThreadPool之中实际上是没有任何线程的,它几乎是不占用任何系统资源的.

#### <span id="head8">5.3 ScheduledThreadPool</span>

```java
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}

public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
            new DelayedWorkQueue());
}
```

通过Executors的newScheduledThreadPool方法来创建.它的核心线程数量是固定的,非核心线程的数量最大是Integer.MAX_VALUE,并且当非核心线程闲置时会被立即回收.ScheduledThreadPool这类线程池主要用于执行定时任务和具有周期的重复任务.

#### <span id="head9">5.4 SingleThreadExecutor</span>

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

通过Executors的newSingleThreadPool方法创建.这类线程池内部只有一个核心线程,它确保所有的任务都在同一个线程中按顺序执行.SingleThreadPool的意义在于统一所有的外界任务到一个线程中,这使得在这些任务之间不需要处理线程同步的问题.
