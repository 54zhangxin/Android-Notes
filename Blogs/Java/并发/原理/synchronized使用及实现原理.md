
### synchronized使用

synchronized是Java中的一种同步锁,它修饰的对象有以下几种:

1. 修改一个代码块,被修饰的代码块称为同步语句块,其作用的范围是大括号{}括起来的代码,传入synchronized的参数为this时是锁的当前对象;传入的参数是obj(自己生成的一个对象)时,锁的是obj这个对象.
2. 修饰一个方法,被修饰的方法称为同步方法,作用范围是整个方法,作用的是当前对象.
3. 修饰一个静态的方法,作用范围是整个静态方法,作用的是这个类
4. 修饰一个类(`synchronized(ClassName.class)`),作用范围是synchronized后面括号括起来的部分,作用的是这个类


注意:

- 无论synchronized关键字加载方法上还是对象上,如果它作用的对象是非静态的,则它取得的锁是对象;如果synchronized作用的对象是一个静态方法或一个类,则它取得的锁是对类,该类所有的对象同一把锁
- 每个对象只有一个锁(lock)与之相关联,谁拿到这个锁谁就可以运行它所控制的那段代码
- 实现同步是要很大的系统开销作为代价的,甚至可能造成死锁,所以尽量避免无谓的同步控制

小结: **对于普通方法,锁是当前实例对象;对于静态方法,锁是当前类的Class对象;对于同步代码块,锁是括号里配置的对象.**

### synchronized原理

**锁方法**: 在编译方法的时候`ACCESS_FLAGS`加一个`ACC_SYNCHRONIZED`标志位,`ACCESS_FLAGS`是访问标志位,除此之外还有常见的public,private,static等.

**锁代码块**: 在代码块的前后增加一对monitorenter和monitorexit指令

在Java 1.6时,synchronized做了大量优化,引入了轻量级锁和偏向锁.此时锁有四种状态,分别是无锁、偏向锁、轻量级锁和重量级锁.这几个状态会随着竞争情况逐渐升级,锁可以升级但不能降级,不过锁降级确实会发生,只不过概率很小,当JVM进入安全点的时候,会检测是否有闲置的Monitor,然后试图进行降级.

在讲四种状态之前,先了解一下对象头.synchronized用的锁的信息是存放在Java对象头的Mard Word标记字段中,它里面保存了对象的HashCode、分代年了和锁标志位.锁标志位用两个bit表示,00表示轻量级锁,10表示重量级锁,01表示偏向锁和无锁,它们两个再用一个bit表示是否是偏向锁.

先说一下偏向锁,为什么要有偏向锁? 在大多数情况下,锁不仅不存在多线程竞争,而且总是由同一个线程多次获得,为了让线程获得锁的代价更低而引入了偏向锁.当一个线程访问同步块并获取锁时,会在对象头里记录锁偏向的线程ID,下次该线程再次进入只需要判断线程ID就可以了.

然后是轻量级锁,当有一个线程竞争获取锁时,由于该锁已经是偏向锁,当发现对象头Mark Word中的线程ID不是自己的线程ID,就会进行CAS操作获取该锁.如果获取到了就替换线程ID,继续保持偏向锁状态,如果获取不到就自旋一段时间再次获取,也就是自旋锁,如果在指定次数没有成功,就会膨胀为重量级锁,当前线程阻塞掉.默认次数是10,当然,后面出了自适应自旋锁,会根据上次自旋的次数来设置.因为长时间的自旋会消耗CPU,所以会有限制次数.轻量级锁适用于线程交替执行同步块的场景,绝大部分的锁在整个同步周期都不存在长时间的竞争.

